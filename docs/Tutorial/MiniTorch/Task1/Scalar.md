这一节请参考 [scalar](https://minitorch.github.io/module1/scalar/)

这里补充一些内容

在[上一节](./Derivatives.md)中，我们讨论了计算导数的两种方法。符号导数需要访问完整的符号函数，而数值导数只需要一个黑盒函数。前者精确但死板，后者不精确但更灵活。本模块将介绍第三种方法，即在符号方法和数值方法之间进行权衡的自求导法。

自动微分法的工作原理是收集函数内部使用的计算路径信息，然后将这些信息转化为计算导数的程序。与黑箱法不同，自动微分法允许我们利用这些信息更精确地计算每一步。

不过，为了收集计算路径信息，我们需要跟踪函数的内部计算。这可能很难做到，因为 Python 不会直接公开函数是如何使用其输入的：我们得到的只是输出。本文档介绍了一种跟踪计算的方法。

由于我们无法访问底层语言解释器，我们将建立一个系统来跟踪应用于每个数字的数学运算。

将所有数字替换为代理类，我们将其称为标量（Scalar）。
用代理运算符替换所有数学函数。
记住对每个标量应用了哪些运算符。

